// Generated by CoffeeScript 1.10.0
(function() {
  var isBuffer, js_type_of, log, njs_util, ref, rpr,
    slice = [].slice;

  log = console.log;

  rpr = function(x) {
    return (require('util')).inspect(x, false, 22);
  };

  njs_util = require('util');

  js_type_of = function(x) {
    return Object.prototype.toString.call(x);
  };


  /* There appear to have been some changes in NodeJS concerning where to find `isXY` methods: */

  isBuffer = (ref = Buffer.isBuffer) != null ? ref : njs_util.isBuffer;

  this._coffeenode_type_by_js_type = {
    '[object Array]': 'list',
    '[object Function]': 'function',
    '[object String]': 'text',
    '[object Generator]': 'generator',
    '[object Arguments]': 'arguments',
    '[object Date]': 'date',
    '[object Error]': 'error',
    '[object global]': 'global',
    '[object RegExp]': 'regex',
    '[object DOMWindow]': 'window',
    '[object CanvasRenderingContext2D]': 'canvasrenderingcontext2d',
    '[object ArrayBuffer]': 'arraybuffer',
    '[object Object]': function(x) {
      if (isBuffer(x)) {
        return 'buffer';
      }
      return 'pod';
    },
    '[object Number]': function(x) {

      /* TAINT isNaN is broken as per https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/isNaN#Description */
      if (isNaN(x)) {
        return 'nan';
      }
      return 'number';
    }
  };

  this.type_of = function(x) {
    "Given any kind of value ``x``, return its type.";
    var R, js_type;
    switch (x) {
      case null:
        return 'null';
      case void 0:
        return 'undefined';
      case true:
      case false:
        return 'boolean';
      case -Infinity:
      case Infinity:
        return 'infinity';
    }
    R = x['~isa'];
    if (R != null) {
      return R;
    }
    if (Buffer.isBuffer(x)) {
      return 'buffer';
    }
    js_type = js_type_of(x);
    R = this._coffeenode_type_by_js_type[js_type];
    if (R == null) {
      return (js_type.replace(/^\[object (.+)\]$/, '$1')).toLowerCase();
    }
    if (this.isa_function(R)) {
      return R(x);
    } else {
      return R;
    }
  };

  this.isa = function(x, probe) {
    "Given any value ``x`` and a non-empty text ``probe``, return whether ``TYPES/type_of x`` equals\n``probe``.";
    return (this.type_of(x)) === probe;
  };

  this.isa_list = function(x) {
    return (js_type_of(x)) === '[object Array]';
  };

  this.isa_boolean = function(x) {
    return (js_type_of(x)) === '[object Boolean]';
  };

  this.isa_function = function(x) {
    return (js_type_of(x)) === '[object Function]';
  };

  this.isa_pod = function(x) {
    return (js_type_of(x)) === '[object Object]' && !isBuffer(x);
  };

  this.isa_text = function(x) {
    return (js_type_of(x)) === '[object String]';
  };

  this.isa_number = function(x) {
    return (js_type_of(x)) === '[object Number]' && isFinite(x);
  };

  this.isa_null = function(x) {
    return x === null;
  };

  this.isa_jsundefined = function(x) {
    return x === void 0;
  };

  this.isa_infinity = function(x) {
    return x === Infinity || x === -Infinity;
  };

  this.isa_jsarguments = function(x) {
    return (js_type_of(x)) === '[object Arguments]';
  };


  /* TAINT isNaN is broken as per https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/isNaN#Description */

  this.isa_jsnotanumber = function(x) {
    return isNaN(x);
  };

  this.isa_jsdate = function(x) {
    return (js_type_of(x)) === '[object Date]';
  };

  this.isa_jsglobal = function(x) {
    return (js_type_of(x)) === '[object global]';
  };

  this.isa_jsregex = function(x) {
    return (js_type_of(x)) === '[object RegExp]';
  };

  this.isa_jserror = function(x) {
    return (js_type_of(x)) === '[object Error]';
  };

  this.isa_jswindow = function(x) {
    return (js_type_of(x)) === '[object DOMWindow]';
  };

  this.isa_jsctx = function(x) {
    return (js_type_of(x)) === '[object CanvasRenderingContext2D]';
  };

  this.isa_jsarraybuffer = function(x) {
    return (js_type_of(x)) === '[object ArrayBuffer]';
  };

  this.isa_jsbuffer = isBuffer;

  if (njs_util.isArray != null) {
    this.isa_list = njs_util.isArray;
  }

  if (njs_util.isRegExp != null) {
    this.isa_jsregex = njs_util.isRegExp;
  }

  if (njs_util.isDate != null) {
    this.isa_jsdate = njs_util.isDate;
  }

  if (njs_util.isBoolean != null) {
    this.isa_boolean = njs_util.isBoolean;
  }

  if (njs_util.isError != null) {
    this.isa_jserror = njs_util.isError;
  }

  if (njs_util.isFunction != null) {
    this.isa_function = njs_util.isFunction;
  }

  if (njs_util.isPrimitive != null) {
    this.isa_primitive = njs_util.isPrimitive;
  }

  if (njs_util.isString != null) {
    this.isa_text = njs_util.isString;
  }

  if (njs_util.isUndefined != null) {
    this.isa_jsundefined = njs_util.isUndefined;
  }

  this.simple_equality_types = {
    'number': true,
    'infinity': true,
    'text': true,
    'boolean': true,
    'null': true,
    'jsundefined': true
  };

  this.simple_comparison_types = {
    'number': true,
    'infinity': true,
    'text': true,
    'boolean': true,
    'null': true
  };

  this.validate_isa = function() {
    var i, len, message, probe_type, type, types, x;
    x = arguments[0], types = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    if (types.length === 0) {
      throw new Error("expected one or more types, got none");
    }
    probe_type = this.type_of(x);
    for (i = 0, len = types.length; i < len; i++) {
      type = types[i];
      if (type === probe_type) {
        return null;
      }
    }
    if (types.length === 1) {
      message = "expected a " + types[0] + ", got a " + probe_type;
    } else {
      types = types.join(', ');
      message = "expected value to have one of these types: " + types + ", got a " + probe_type;
    }
    return null;
  };

  (function(_this) {
    return (function() {
      var match, name, results, type;
      results = [];
      for (name in _this) {
        match = name.match(/^isa_(.+)/);
        if (match == null) {
          continue;
        }
        type = match[1];
        results.push((function(name, type) {
          return _this["validate_" + name] = function(x) {
            if (this[name](x)) {
              return null;
            }
            throw new Error("expected a " + type + ", got a " + (this.type_of(x)));
          };
        })(name, type));
      }
      return results;
    });
  })(this)();

}).call(this);

//# sourceMappingURL=TYPES.js.map
