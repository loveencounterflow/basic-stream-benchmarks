// Generated by CoffeeScript 1.10.0
(function() {
  var CND, TRM, alert, badge, debug, echo, help, include, info, log, njs_path, praise, rpr, test, urge, warn, whisper,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  njs_path = require('path');

  TRM = require('./TRM');

  rpr = TRM.rpr.bind(TRM);

  badge = 'BITSNPIECES/test';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  urge = TRM.get_logger('urge', badge);

  praise = TRM.get_logger('praise', badge);

  echo = TRM.echo.bind(TRM);

  CND = require('./main');

  test = require('guy-test');

  this["test type_of"] = function(T) {
    T.eq(CND.type_of(new WeakMap()), 'weakmap');
    T.eq(CND.type_of(new Map()), 'map');
    T.eq(CND.type_of(new Set()), 'set');
    T.eq(CND.type_of(new Date()), 'date');
    T.eq(CND.type_of(new Error()), 'error');
    T.eq(CND.type_of([]), 'list');
    T.eq(CND.type_of(true), 'boolean');
    T.eq(CND.type_of(false), 'boolean');
    T.eq(CND.type_of((function() {})), 'function');
    T.eq(CND.type_of((function*() {
      return (yield 123);
    })()), 'generator');
    T.eq(CND.type_of(null), 'null');
    T.eq(CND.type_of('helo'), 'text');
    T.eq(CND.type_of(void 0), 'undefined');
    T.eq(CND.type_of(arguments), 'arguments');
    T.eq(CND.type_of(global), 'global');
    T.eq(CND.type_of(/^xxx$/g), 'regex');
    T.eq(CND.type_of({}), 'pod');
    T.eq(CND.type_of(NaN), 'nan');
    T.eq(CND.type_of(1 / 0), 'infinity');
    T.eq(CND.type_of(-1 / 0), 'infinity');
    T.eq(CND.type_of(12345), 'number');
    T.eq(CND.type_of(new Buffer('helo')), 'buffer');
    T.eq(CND.type_of(new ArrayBuffer(42)), 'arraybuffer');
    T.eq(CND.type_of(new Int8Array(5)), 'int8array');
    T.eq(CND.type_of(new Uint8Array(5)), 'uint8array');
    T.eq(CND.type_of(new Uint8ClampedArray(5)), 'uint8clampedarray');
    T.eq(CND.type_of(new Int16Array(5)), 'int16array');
    T.eq(CND.type_of(new Uint16Array(5)), 'uint16array');
    T.eq(CND.type_of(new Int32Array(5)), 'int32array');
    T.eq(CND.type_of(new Uint32Array(5)), 'uint32array');
    T.eq(CND.type_of(new Float32Array(5)), 'float32array');
    T.eq(CND.type_of(new Float64Array(5)), 'float64array');
    return null;
  };

  this["test size_of"] = function(T) {
    T.eq(CND.size_of([1, 2, 3, 4]), 4);
    T.eq(CND.size_of(new Buffer([1, 2, 3, 4])), 4);
    T.eq(CND.size_of('𣁬𡉜𠑹𠅁'), 2 * (Array.from('𣁬𡉜𠑹𠅁')).length);
    T.eq(CND.size_of('𣁬𡉜𠑹𠅁', {
      count: 'codepoints'
    }), (Array.from('𣁬𡉜𠑹𠅁')).length);
    T.eq(CND.size_of('𣁬𡉜𠑹𠅁', {
      count: 'codeunits'
    }), 2 * (Array.from('𣁬𡉜𠑹𠅁')).length);
    T.eq(CND.size_of('𣁬𡉜𠑹𠅁', {
      count: 'bytes'
    }), (new Buffer('𣁬𡉜𠑹𠅁', 'utf-8')).length);
    T.eq(CND.size_of('abcdefghijklmnopqrstuvwxyz'), 26);
    T.eq(CND.size_of('abcdefghijklmnopqrstuvwxyz', {
      count: 'codepoints'
    }), 26);
    T.eq(CND.size_of('abcdefghijklmnopqrstuvwxyz', {
      count: 'codeunits'
    }), 26);
    T.eq(CND.size_of('abcdefghijklmnopqrstuvwxyz', {
      count: 'bytes'
    }), 26);
    T.eq(CND.size_of('ä'), 1);
    T.eq(CND.size_of('ä', {
      count: 'codepoints'
    }), 1);
    T.eq(CND.size_of('ä', {
      count: 'codeunits'
    }), 1);
    T.eq(CND.size_of('ä', {
      count: 'bytes'
    }), 2);
    T.eq(CND.size_of(new Map([['foo', 42], ['bar', 108]])), 2);
    T.eq(CND.size_of(new Set(['foo', 42, 'bar', 108])), 4);
    T.eq(CND.size_of({
      'foo': 42,
      'bar': 108,
      'baz': 3
    }), 3);
    return T.eq(CND.size_of({
      '~isa': 'XYZ/yadda',
      'foo': 42,
      'bar': 108,
      'baz': 3
    }), 4);
  };

  this["is_subset"] = function(T) {
    T.eq(false, CND.is_subset(Array.from('abcde'), Array.from('abcd')));
    T.eq(false, CND.is_subset(Array.from('abcx'), Array.from('abcd')));
    T.eq(false, CND.is_subset(Array.from('abcd'), []));
    T.eq(true, CND.is_subset(Array.from('abcd'), Array.from('abcd')));
    T.eq(true, CND.is_subset(Array.from('abc'), Array.from('abcd')));
    T.eq(true, CND.is_subset([], Array.from('abcd')));
    T.eq(true, CND.is_subset([], Array.from([])));
    T.eq(false, CND.is_subset(new Set('abcde'), new Set('abcd')));
    T.eq(false, CND.is_subset(new Set('abcx'), new Set('abcd')));
    T.eq(false, CND.is_subset(new Set('abcx'), new Set()));
    T.eq(true, CND.is_subset(new Set('abcd'), new Set('abcd')));
    T.eq(true, CND.is_subset(new Set('abc'), new Set('abcd')));
    T.eq(true, CND.is_subset(new Set(), new Set('abcd')));
    T.eq(true, CND.is_subset(new Set(), new Set()));
    return null;
  };

  this["deep_copy"] = function(T) {

    /* TAINT set comparison doesn't work */
    var i, len, probe, probes, result;
    probes = [
      [
        'foo', 42, [
          'bar', (function() {
            return 'xxx';
          })
        ], {
          q: 'Q',
          s: 'S'
        }
      ]
    ];
    for (i = 0, len = probes.length; i < len; i++) {
      probe = probes[i];
      result = CND.deep_copy(probe);
      T.eq(result, probe);
      T.ok(result !== probe);
    }
    return null;
  };

  this["XJSON (1)"] = function(T) {
    var d, e;
    e = new Set('xy');
    e.add(new Set('abc'));
    d = ['A', 'B', e];
    T.eq(CND.XJSON.stringify(d), "[\"A\",\"B\",{\"~isa\":\"-x-set\",\"%self\":[\"x\",\"y\",{\"~isa\":\"-x-set\",\"%self\":[\"a\",\"b\",\"c\"]}]}]");

    /* TAINT doing string comparison here to avoid implicit test that T.eq deals with sets correctly */
    T.eq(rpr(CND.XJSON.parse(CND.XJSON.stringify(d))), "[ 'A', 'B', Set { 'x', 'y', Set { 'a', 'b', 'c' } } ]");
    return null;
  };

  this["XJSON (2)"] = function(T) {
    var d, d_json, d_ng, d_ng_json, f, m, s;
    s = new Set(Array.from('Popular Mechanics'));
    m = new Map([['a', 1], ['b', 2]]);
    f = function(x) {
      return Math.pow(x, 2);
    };
    d = {
      s: s,
      m: m,
      f: f
    };
    d_json = CND.XJSON.stringify(d);
    d_ng = CND.XJSON.parse(d_json);
    d_ng_json = CND.XJSON.stringify(d_ng);
    T.eq(d_json, d_ng_json);

    /* TAINT using T.eq directly on values, not their alternative serialization would implicitly test whether
    CND.equals accepts sets and maps
     */
    T.eq(rpr(d_ng['s']), rpr(d['s']));
    T.eq(rpr(d_ng['m']), rpr(d['m']));
    T.eq(d_ng['f'], d['f']);
    T.eq(d_ng['f'](12), d['f'](12));
    T.eq(d_ng['f'](12), 144);
    return null;
  };

  this["XJSON (3)"] = function(T) {
    var d, d_json, d_ng, d_ng_text;
    d = {
      my_number: 42,
      my_buffer: Buffer.from([127, 128, 129]),
      my_null: null,
      my_nan: NaN,
      my_local_symbol: Symbol('local-symbol'),
      my_global_symbol: Symbol["for"]('global-symbol')
    };
    d[Symbol["for"]('foo')] = 'bar';
    d[Symbol('FOO')] = 'BAR';
    d_json = CND.XJSON.stringify(d);
    d_ng = CND.XJSON.parse(d_json);
    T.eq(d_ng.my_number, d.my_number);
    T.eq(d_ng.my_buffer, d.my_buffer);
    T.eq(d_ng.my_null, d.my_null);
    T.eq(d_ng.my_nan, d.my_nan);
    T.eq(d_ng.my_global_symbol, d.my_global_symbol);

    /* NOTE it's not possible to recreate the identity of a local symbol, so we check value and status: */
    T.eq(d_ng.my_local_symbol.toString(), d.my_local_symbol.toString());
    d_ng_text = d_ng.my_local_symbol.toString().replace(/^Symbol\((.*)\)$/, '$1');
    T.ok(d.my_local_symbol !== Symbol["for"](d_ng_text));
    return null;
  };

  this._main = function(handler) {
    return test(this, {
      'timeout': 2500
    });
  };

  this._prune = function() {
    var name, value;
    for (name in this) {
      value = this[name];
      if (name.startsWith('_')) {
        continue;
      }
      if (indexOf.call(include, name) < 0) {
        delete this[name];
      }
    }
    return null;
  };

  if (module.parent == null) {
    include = ["test type_of", "test size_of", "is_subset", "deep_copy", "XJSON (1)", "XJSON (2)", "XJSON (3)"];
    this._prune();
    this._main();
  }

}).call(this);

//# sourceMappingURL=tests.js.map
