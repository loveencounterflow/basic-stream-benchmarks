// Generated by CoffeeScript 1.11.1
(function() {
  var $, $as_line, $async, $show, $split, CND, D, FS, O, PATH, V8PROFILER, badge, debug, echo, flamegraph, flamegraph_from_stream, format_float, format_integer, help, info, new_numeral, report, rpr, running_in_devtools, start_profile, step, stop_profile, through2, warn, whisper, write_flamegraph;

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'BASIC-STREAM-BENCHMARKS';

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  info = CND.get_logger('info', badge);

  help = CND.get_logger('help', badge);

  whisper = CND.get_logger('whisper', badge);

  echo = CND.echo.bind(CND);

  PATH = require('path');

  FS = require('fs');

  through2 = require('through2');

  $split = require('binary-split');

  new_numeral = require('numeral');

  format_float = function(x) {
    return (new_numeral(x)).format('0,0.000');
  };

  format_integer = function(x) {
    return (new_numeral(x)).format('0,0');
  };

  step = require('coffeenode-suspend').step;

  O = {};

  O.inputs = {};

  O.inputs['long'] = PATH.resolve(__dirname, '../test-data/Unicode-NamesList.txt');

  O.inputs['short'] = PATH.resolve(__dirname, '../test-data/Unicode-NamesList-short.txt');

  D = require('pipedreams');

  $ = D.$, $async = D.$async;


  /* Avoid to try to require `v8-profiler` when running this module with `devtool`: */

  running_in_devtools = console.profile != null;

  V8PROFILER = running_in_devtools ? null : require('v8-profiler');

  flamegraph = require('flamegraph');

  flamegraph_from_stream = require('flamegraph/from-stream');

  $show = function() {
    return through2(function(data, encoding, callback) {
      this.push(data);
      return callback();
    });
  };

  $as_line = function() {
    return through2(function(data, encoding, callback) {
      this.push(data + '\n');
      return callback();
    });
  };

  report = function(S) {
    var bps, bps_txt, byte_count_txt, dts, dts_txt, ips, ips_txt, item_count_txt, line;
    format_integer = function(x) {
      return "" + x;
    };
    format_float = function(x) {
      return x.toFixed(3);
    };
    dts = (S.t1 - S.t0) / 1000;
    bps = S.byte_count / dts;
    ips = S.item_count / dts;
    byte_count_txt = format_integer(S.byte_count);
    item_count_txt = format_integer(S.item_count);
    dts_txt = format_float(dts);
    bps_txt = format_float(bps);
    ips_txt = format_float(ips);
    line = [];
    if (report.is_first) {
      report.is_first = false;
      echo(CND.lime(['job', 'n', 'mode', 'dt', 'bytes', 'items', 'bps', 'ips'].join('\t')));
    }
    line.push(S.job_name);
    line.push(S.n);
    line.push(S.mode);
    line.push(dts_txt);
    line.push(byte_count_txt);
    line.push(item_count_txt);
    line.push(bps_txt);
    line.push(ips_txt);
    echo(CND.steel(line.join('\t')));
    return null;
  };

  report.is_first = true;

  start_profile = function(S) {
    if (running_in_devtools) {
      return console.profile(S.job_name);
    } else {
      return V8PROFILER.startProfiling(S.job_name);
    }
  };

  stop_profile = function(S, handler) {
    if (running_in_devtools) {
      return console.profileEnd(S.job_name);
    } else {
      return step(function*(resume) {
        var profile, profile_data;
        profile = V8PROFILER.stopProfiling(S.job_name);
        profile_data = (yield profile["export"](resume));
        S.profile_name = "profile-" + S.job_name + ".json";
        FS.writeFileSync(S.profile_name, profile_data);
        return handler();
      });
    }
  };

  write_flamegraph = function(S, handler) {
    var callgraph_lines, source;
    if (running_in_devtools) {
      return;
    }
    S.flamegraph_name = "flamegraph-" + S.job_name + ".svg";
    source = D.new_stream('utf-8', {
      path: S.profile_name
    });
    callgraph_lines = null;

    /* TAINT stream returned by `flamegraph_from_stream` apparently doesn't emit `close` events, so we
    chose another way to do it:
     */
    source.pipe(D.$split()).pipe(D.$collect()).pipe($(function(lines) {
      return callgraph_lines = lines;
    })).pipe($('finish', function() {
      var svg;
      svg = flamegraph(callgraph_lines, {
        type: 'cpuprofile'
      });
      FS.writeFileSync(S.flamegraph_name, svg);
      return handler();
    }));
    return null;
  };

  this.read_with_transforms = function(n, size, mode, handler) {
    var S, _, i, input, input_path, output, output_path, p, ref;
    input_path = O.inputs[size];
    if (input_path == null) {
      throw new Error("unknown input size " + (rpr(size)));
    }
    if (mode !== 'sync' && mode !== 'async') {
      throw new Error("unknown mode " + (rpr(mode)));
    }
    output_path = '/dev/null';
    input = FS.createReadStream(input_path);
    output = FS.createWriteStream(output_path);
    S = {};
    S.n = n;
    S.size = size;
    S.mode = mode;
    S.byte_count = 0;
    S.item_count = 0;
    S.t0 = null;
    S.t1 = null;
    S.job_name = "n=" + n + ",size=" + size + ",mode=" + mode;
    p = input;
    p = p.pipe($split());
    p = p.pipe(through2.obj(function(data, encoding, callback) {
      if (S.t0 == null) {
        start_profile(S);
        if (S.t0 == null) {
          S.t0 = Date.now();
        }
      }
      S.byte_count += data.length;
      S.item_count += +1;
      this.push(data);
      return callback();
    }));
    for (_ = i = 1, ref = n; i <= ref; _ = i += +1) {
      if (mode === 'sync') {
        p = p.pipe(through2.obj(function(data, encoding, callback) {
          this.push(data);
          return callback();
        }));
      } else {
        p = p.pipe(through2.obj(function(data, encoding, callback) {
          return setImmediate((function(_this) {
            return function() {
              _this.push(data);
              return callback();
            };
          })(this));
        }));
      }
    }
    p = p.pipe($as_line());
    p = p.pipe(output);
    output.on('close', function() {
      return step(function*(resume) {
        yield stop_profile(S, resume);
        S.t1 = Date.now();
        report(S);
        yield write_flamegraph(S, resume);
        return handler();
      });
    });
    return null;
  };

  this.main = function() {
    var n_max;
    n_max = running_in_devtools ? 3 : 1;
    return step((function(_this) {
      return function*(resume) {
        var i, j, k, l, len, len1, len2, mode, n, ref, ref1, ref2, ref3, run, size;
        for (run = i = 1, ref = n_max; 1 <= ref ? i <= ref : i >= ref; run = 1 <= ref ? ++i : --i) {
          ref1 = ['sync', 'async'];
          for (j = 0, len = ref1.length; j < len; j++) {
            mode = ref1[j];
            ref2 = ['short'];
            for (k = 0, len1 = ref2.length; k < len1; k++) {
              size = ref2[k];
              ref3 = [1, 10, 100];
              for (l = 0, len2 = ref3.length; l < len2; l++) {
                n = ref3[l];
                yield _this.read_with_transforms(n, size, mode, resume);
              }
            }
          }
        }
        if (running_in_devtools) {
          return setTimeout((function() {
            return help('ok');
          }), 1e6);
        }
      };
    })(this));
  };

  if (module.parent == null) {
    this.main();
  }

}).call(this);

//# sourceMappingURL=main.js.map
