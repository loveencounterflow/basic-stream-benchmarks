// Generated by CoffeeScript 1.12.1
(function() {
  var $logger, $map, $on_end, $random, $sequence, $split, $stringify, $utf8, CND, FS, O, PATH, badge, count, debug, echo, format_float, format_integer, help, id, info, input, mkdirp, new_numeral, output, parseCsv, paths, pipeline, prop, pull, rpr, t0, t1, through, through2, to_pull, urge, values, warn, whisper;

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'BASIC-STREAM-BENCHMARKS/COPY-LINES';

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  info = CND.get_logger('info', badge);

  urge = CND.get_logger('urge', badge);

  help = CND.get_logger('help', badge);

  whisper = CND.get_logger('whisper', badge);

  echo = CND.echo.bind(CND);

  PATH = require('path');

  FS = require('fs');

  through2 = require('through2');

  $split = require('binary-split');

  O = {};

  O.inputs = {};

  O.outputs = {};

  O.inputs.long = PATH.resolve(__dirname, '../test-data/Unicode-NamesList.txt');

  O.inputs.short = PATH.resolve(__dirname, '../test-data/Unicode-NamesList-short.txt');

  O.inputs.tiny = PATH.resolve(__dirname, '../test-data/Unicode-NamesList-tiny.txt');

  O.outputs.lines = PATH.resolve(__dirname, '/tmp/basic-stream-benchmarks/lines.txt');

  new_numeral = require('numeral');

  format_float = function(x) {
    return (new_numeral(x)).format('0,0.000');
  };

  format_integer = function(x) {
    return (new_numeral(x)).format('0,0');
  };

  mkdirp = require('mkdirp');

  pull = require('pull-stream');

  $split = require('pull-split');

  through = require('pull-through');


  /* https://github.com/dominictarr/pull-stream-examples/blob/master/compose.js */

  parseCsv = function() {
    return pull($split(), pull.map(function(line) {
      return line.split(/,\s+/);
    }));
  };

  paths = [PATH.resolve(__dirname, './copy-lines.js'), PATH.resolve(__dirname, './copy-lines-with-pull-stream.js'), PATH.resolve(__dirname, './main.js'), PATH.resolve(__dirname, './patch-event-emitter.js')];


  /* http://dominictarr.com/post/149248845122/pull-streams-pull-streams-are-a-very-simple */

  
function values(array) {
  var i = 0
  return function (abort, cb) {
    if(abort) return cb(abort)
    return cb(i >= array.length ? true : null, array[i++])
  }
}
;

  values = function(list) {

    /* source */
    var idx;
    idx = 0;
    return function(end, handler) {
      if (end) {
        return handler(end);
      }
      if (idx >= list.length) {
        return handler(true);
      }
      idx += +1;
      return handler(null, list[idx - 1]);
    };
  };

  $random = function(n) {

    /* source */
    return function(end, handler) {
      if (end) {
        return handler(end);
      }

      /* only read n times, then stop */
      n += -1;
      if (n < 0) {
        return handler(true);
      }
      return handler(null, Math.random());
    };
  };

  $sequence = function(n) {

    /* source */
    var Z;
    Z = 0;
    return function(end, handler) {
      if (end) {
        return handler(end);
      }
      Z += +1;
      if (Z > n) {
        return handler(true);
      }
      return handler(null, Z);
    };
  };

  $logger = function() {

    /* sink */
    return function(read) {
      var next;
      next = function(end, data) {
        if (end === true) {
          return;
        }
        if (end) {
          throw end;
        }
        info('>>>', data);
        return read(null, next);
      };
      read(null, next);
      return null;
    };
  };

  prop = require('pull-stream/util/prop');

  id = function(e) {
    return e;
  };

  $map = function(mapper) {
    debug('22201', mapper);
    if (mapper == null) {
      return id;
    }
    mapper = prop(mapper);
    return function(read) {
      return function(abort, handler) {
        read(abort, function(end, data) {
          var error;
          debug('23201', data);
          try {
            data = !end ? mapper(data) : null;
          } catch (error1) {
            error = error1;
            return read(error, function() {
              return handler(error);
            });
          }
          handler(end, data);
        });
      };
    };
  };


  /*  * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */


  /*   * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */

  pipeline = [
    $sequence(4), $map(function(data) {
      whisper('+++', data);
      return Math.pow(data, 2);
    }), through(function(data) {
      whisper('###', data);
      return this.queue(data);
    }), $logger()
  ];

  pull.apply(null, pipeline);

  $logger()($random(5));

  pipeline = [
    pull.values([1, 2, 3]), through(function(data) {
      return this.queue(data * 10);
    }), pull.collect(function(error, collector) {
      if (error != null) {
        throw error;
      }
      return debug('***', collector);
    })
  ];

  pull.apply(null, pipeline);

  $stringify = require('pull-stringify');

  $split = require('pull-split');

  $utf8 = require('pull-utf8-decoder');

  $on_end = require('pull-stream/sinks/on-end');

  to_pull = require('stream-to-pull-stream');

  input = FS.createReadStream(PATH.resolve(__dirname, '../test-data/ids.txt'));

  output = FS.createWriteStream('/tmp/formulas.txt');

  t0 = null;

  t1 = null;

  count = 0;

  pipeline = [
    to_pull.source(input), through((function() {
      var is_first;
      is_first = true;
      return function(data) {
        if (is_first) {
          is_first = false;
          t0 = Date.now();
        }
        return this.queue(data);
      };
    })()), $utf8(), $split(), pull.map(function(line) {
      count += +1;
      return line;
    }), pull.map(function(line) {
      return line.trim();
    }), pull.filter(function(line) {
      return line.length > 0;
    }), pull.filter(function(line) {
      return !line.startsWith('#');
    }), pull.filter(function(line) {
      return /é­š/.test(line);
    }), pull.map(function(line) {
      return line.split('\t');
    }), pull.map(function(fields) {
      var _, formula, glyph;
      _ = fields[0], glyph = fields[1], formula = fields[2];
      return [glyph, formula];
    }), pull.map(function(fields) {
      return JSON.stringify(fields);
    }), pull.map(function(line) {
      return line + '\n';
    }), to_pull.sink(output, function(error) {
      var dts, ips;
      if (error != null) {
        throw error;
      }
      t1 = Date.now();
      dts = (t1 - t0) / 1000;
      ips = count / dts;
      help("dts: " + (format_float(dts)) + ", ips: " + (format_float(ips)));
      return help('ok');
    })
  ];

  pull.apply(null, pipeline);

}).call(this);

//# sourceMappingURL=copy-lines-with-pull-stream.js.map
